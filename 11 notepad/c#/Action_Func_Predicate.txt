Action<T> Delegate
	.NET의 Action<T> delegate는 하나의 파라미터를 받아들이고, 리턴 값이 없는 함수에 사용되는 Delegate 
	Action delegate는 System 네임스페이스에서 제공 
	파라미터의 수에 따라 0개부터 16개의 파라미터까지 받아들이는 delegate 존재
	중요한 특징은 리턴 값이 없어야 한다는 점이다.

Func<T, TResult> Delegate
	.NET의 Func<T> delegate는 Action delegate와 비슷
	Action이 리턴값이 없는 경우 사용되는 반면, Func는 반드시 리턴 타입이 - Generic 폼 내에, 즉 템플릿 파라미터 안에 - 존재
	Func<T>의 T는 리턴값의 타입을 가리키며, 이 경우 입력파라미터는 없다 (일반적으로 T를 입력과 구분하기 위해 TResult로 표현한다)
	Action과 마찬가지로 입력 파라미터수에 따라 여러 변형이 존재
	입력이 1개인 경우 Func<T, TResult>, 입력이 2개인 경우 Func<T1, T2, TResult> 를 사용 
	Action 과 같이 16개까지 입력파라미터를 받아 들일 수 있다


Predicate<T> Delegate
	.NET의 Predicate<T> delegate는 Action/Func delegate와 비슷
	리턴값이 반드시 bool이고 입력값이 T 타입인 delegate
	Action이나 Func와 달리, 입력 파라미터는 1개 
	delegate는 .NET의 Array나 List 클래스의 메서드들에서 자주 사용 
	Predicate<T>은 Func<T, bool>와 같이 표현할 수 있는데, Func이 실제로 보다 많은 함수들을 표현할 수 있다. 
	Predicate은 .NET 2.0에서 Array나 List등을 지원하기 위해 만들어 졌으며, 보다 일반화된 Func는 .NET 3.5에서 도입되어 LINQ 등을 지원하도록 만들어 졌다.

		// Predicate<T>
		Predicate<int> p = delegate(int n)
		{
		   return n >= 0;
		};
		bool res = p(-1);

		Predicate<string> p2 = s => s.StartsWith("A");
		res = p2("Apple");


Delegate의 사용
	Action, Predicate, Func 등의 Delegate는 .NET Framework에서 많이 사용 
	많은 경우 이들 Delegate들은 .NET Framework의 기존 메서드들에서 요구되는 파라미터로 사용되는 경우가 많다.
	Predicate는 Array나 List의 메서드들에서 많이 사용 Func는 LINQ 에서 많이 사용된다. 	
	
		public void Run()
		{
			int[] arr = { -10, 20, -30, 4, -5 };
			
			// Predicate의 사용
			//   Array.Find(int[], Predicate<int>)    
			int pos = Array.Find(arr, IsPositive);

			// LINQ에서 Func의 사용
			//   Where(Func<int, bool> predicate)
			var v = arr.Where(n => n >= 0);
		}

		bool IsPositive(int i)
		{
			return i >= 0;
		}